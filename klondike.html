<!DOCTYPE html>
<html>
<head>
	<title>Klondike Solitaire</title>
	<style type="text/css">
		html, body { margin: 0; padding: 0; }
		#backbuffer {
			height: 100%;
			width: 100%;
			background-color: #207346;
		}
	</style>
</head>
<body>
<canvas id="backbuffer"></canvas>
<script type="text/javascript">
	var backbuffer = document.querySelector("#backbuffer");
	backbuffer.width = window.innerWidth;
	backbuffer.height = window.innerHeight;

	const Suites = {
		HEARTS: "H",
		DIAMONDS: "D",
		CLUBS: "C",
		SPADES: "S"
	}

	const Ranks = {
		KING: "K",
		QUEEN: "Q",
		JACK: "J",
		TEN: "10",
		NINE: "9",
		EIGHT: "8",
		SEVEN: "7",
		SIX: "6",
		FIVE: "5",
		FOUR: "4",
		THREE: "3",
		TWO: "2",
		ACE: "A"
	}

	class Card {
		static tableauNumber = 7;
		static width = 60;
		static height = 80;
		static pileOffset = 16;
		Color() { return this.suite == Suites.HEARTS || this.suite == Suites.DIAMONDS ? "#ff0000" : "#000000"; }

		constructor(suite, rank) {
			this.parent = null;
			this.children = null;
			this.suite = suite;
			this.rank = rank;
			this.face = false;
		}

		static CreateDeck() {
			var deck = [];
			for (var suite in Suites) {
				for (var rank in Ranks) {
					deck.push(new Card(suite, rank));
				}
			}
			return deck;
		}

		static CreateTableau() {
			var tableau = [];
			for (var t = 0; t < this.tableauNumber; t++) {
				tableau.push([]);
			}
			return tableau;
		}

		static Shuffle(deck) {
			var currentIndex = deck.length, temporaryValue, randomIndex;
		
			// While there remain elements to shuffle...
			while (0 !== currentIndex) {
				// Pick a remaining element...
				randomIndex = Math.floor(Math.random() * currentIndex);
				currentIndex -= 1;
		
				// And swap it with the current element.
				temporaryValue = deck[currentIndex];
				deck[currentIndex] = deck[randomIndex];
				deck[randomIndex] = temporaryValue;
			}
			return deck;
		}

		static DrawCardFrom(deck) { return deck.pop(); }

		ToggleFace() {
			this.face = !this.face;
		}

		PileTo(parent) {
			this.parent = parent;
			parent.children = this;
		}

		Draw(graphics, x, y) {
			if (this.face) {
				graphics.context.fillStyle = "#efefef";
				graphics.context.fillRect(x, y, Card.width, Card.height);
				graphics.context.strokeRect(x, y, Card.width, Card.height);
				graphics.drawText(this.suite + "-" + this.rank, x + (Card.width / 2), y + (Card.height / 2), this.Color(), "center");
			} else {
				graphics.context.fillStyle = "#aaaaff";
				graphics.context.fillRect(x, y, Card.width, Card.height);
				graphics.context.strokeRect(x, y, Card.width, Card.height);
			}
			if (this.children != null) Draw(graphics);
		}
	}

	var graphics = {
		context: backbuffer.getContext("2d"),
		markerOffset: 4,
		cardStart: 32,
		cardGutter: 16,

		init: function() {
			this.context.font = "14px Arial";
		},

		drawText: function(text, x, y, color, align = "left") {
			this.context.textAlign = align;
			this.context.fillStyle = color;
			this.context.fillText(text, x, y);
		},

		drawMarker: function(x, y) {
			this.context.strokeRect(x - this.markerOffset, y - this.markerOffset, Card.width + (this.markerOffset * 2), Card.height + (this.markerOffset * 2));
		},

		getRawPosition(x, y) {
			return {
				x: this.cardStart + ((Card.width + this.cardGutter) * x),
				y: this.cardStart + ((Card.height + this.cardGutter) * y)
			}
		},

		getNextX() { return Card.width + this.cardGutter; },
		getNextY() { return Card.height + this.cardGutter; }
	}

	// Initialize graphics
	graphics.init();

	

	// [ D E C K ]---------------------------------------
	// Create deck
	var deck = Card.CreateDeck();
	Card.Shuffle(deck);

	// Initialize draw coordinate
	var pos = graphics.getRawPosition(0, 0);

	// Draw deck marker
	graphics.drawMarker(pos.x, pos.y);
	// --------------------------------------------------



	// [ F O U N D A T I O N ]---------------------------
	// Reposition draw coordinate for foundation
	pos = graphics.getRawPosition(3, 0);

	// Draw foundation markers
	for (var f = 0; f < 4; f++) {
		graphics.drawMarker(pos.x, pos.y);
		pos.x += graphics.getNextX();
	}
	// --------------------------------------------------



	// [ T A B L E A U ]---------------------------------
	// Create Tableau
	var tableau = Card.CreateTableau();

	// Make incremental pile to tableau
	for (var t = 0; t < tableau.length; t++) {
		for (var p = 0; p < t + 1; p++) {
			tableau[t].push(Card.DrawCardFrom(deck));
		}
		// Open last card on pile in tableau
		tableau[t][tableau[t].length - 1].ToggleFace();
	}

	// Reposition draw coordinate for tableau markers
	pos = graphics.getRawPosition(0, 1.5);

	// Draw tableau markers
	for (var t = 0; t < tableau.length; t++) {
		graphics.drawMarker(pos.x, pos.y);
		pos.x += graphics.getNextX();
	}

	// Reposition draw coordinate for tableau piles
	pos = graphics.getRawPosition(0, 1.5);
	var yPileStart = pos.y;

	// Draw tableau piles
	for (var t = 0; t < tableau.length; t++) {
		for (var p = 0; p < tableau[t].length; p++) {
			tableau[t][p].Draw(graphics, pos.x, pos.y);
			pos.y += Card.pileOffset;
		}
		pos.x += graphics.getNextX();
		pos.y = yPileStart;
	}
	// --------------------------------------------------



</script>
</body>
</html>
